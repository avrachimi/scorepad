// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: matches.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO
  matches (
    id,
    match_date,
    duration_minutes,
    created_by,
    team1_score,
    team1_player1,
    team1_player2,
    team2_score,
    team2_player1,
    team2_player2
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING
  id, match_date, duration_minutes, created_by, team1_score, team1_player1, team1_player2, team2_score, team2_player1, team2_player2, created_at, updated_at
`

type CreateMatchParams struct {
	ID              uuid.UUID
	MatchDate       time.Time
	DurationMinutes int32
	CreatedBy       uuid.UUID
	Team1Score      int32
	Team1Player1    uuid.UUID
	Team1Player2    uuid.NullUUID
	Team2Score      int32
	Team2Player1    uuid.NullUUID
	Team2Player2    uuid.NullUUID
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, createMatch,
		arg.ID,
		arg.MatchDate,
		arg.DurationMinutes,
		arg.CreatedBy,
		arg.Team1Score,
		arg.Team1Player1,
		arg.Team1Player2,
		arg.Team2Score,
		arg.Team2Player1,
		arg.Team2Player2,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.MatchDate,
		&i.DurationMinutes,
		&i.CreatedBy,
		&i.Team1Score,
		&i.Team1Player1,
		&i.Team1Player2,
		&i.Team2Score,
		&i.Team2Player1,
		&i.Team2Player2,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMatch = `-- name: DeleteMatch :exec
DELETE FROM matches
WHERE
  id = $1
  AND created_by = $2::uuid
`

type DeleteMatchParams struct {
	ID        uuid.UUID
	CreatedBy uuid.UUID
}

func (q *Queries) DeleteMatch(ctx context.Context, arg DeleteMatchParams) error {
	_, err := q.db.ExecContext(ctx, deleteMatch, arg.ID, arg.CreatedBy)
	return err
}

const getMatchById = `-- name: GetMatchById :one
SELECT
  m.id, m.match_date, m.duration_minutes, m.created_by, m.team1_score, m.team1_player1, m.team1_player2, m.team2_score, m.team2_player1, m.team2_player2, m.created_at, m.updated_at,
  json_build_object(
    'id',
    u1.id,
    'name',
    u1.name,
    'email',
    u1.email,
    'image_url',
    u1.image_url
  ) AS team1_player1,
  json_build_object(
    'id',
    u2.id,
    'name',
    u2.name,
    'email',
    u2.email,
    'image_url',
    u2.image_url
  ) AS team1_player2,
  json_build_object(
    'id',
    u3.id,
    'name',
    u3.name,
    'email',
    u3.email,
    'image_url',
    u3.image_url
  ) AS team2_player1,
  json_build_object(
    'id',
    u4.id,
    'name',
    u4.name,
    'email',
    u4.email,
    'image_url',
    u4.image_url
  ) AS team2_player2,
  json_build_object(
    'id',
    u5.id,
    'name',
    u5.name,
    'email',
    u5.email,
    'image_url',
    u5.image_url
  ) AS created_by
FROM
  matches m
  LEFT JOIN users u1 ON m.team1_player1 = u1.id
  LEFT JOIN users u2 ON m.team1_player2 = u2.id
  LEFT JOIN users u3 ON m.team2_player1 = u3.id
  LEFT JOIN users u4 ON m.team2_player2 = u4.id
  LEFT JOIN users u5 ON m.created_by = u5.id
WHERE
  m.id = $1
`

type GetMatchByIdRow struct {
	ID              uuid.UUID
	MatchDate       time.Time
	DurationMinutes int32
	CreatedBy       uuid.UUID
	Team1Score      int32
	Team1Player1    uuid.UUID
	Team1Player2    uuid.NullUUID
	Team2Score      int32
	Team2Player1    uuid.NullUUID
	Team2Player2    uuid.NullUUID
	CreatedAt       time.Time
	UpdatedAt       sql.NullTime
	Team1Player1_2  json.RawMessage
	Team1Player2_2  json.RawMessage
	Team2Player1_2  json.RawMessage
	Team2Player2_2  json.RawMessage
	CreatedBy_2     json.RawMessage
}

func (q *Queries) GetMatchById(ctx context.Context, id uuid.UUID) (GetMatchByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getMatchById, id)
	var i GetMatchByIdRow
	err := row.Scan(
		&i.ID,
		&i.MatchDate,
		&i.DurationMinutes,
		&i.CreatedBy,
		&i.Team1Score,
		&i.Team1Player1,
		&i.Team1Player2,
		&i.Team2Score,
		&i.Team2Player1,
		&i.Team2Player2,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Team1Player1_2,
		&i.Team1Player2_2,
		&i.Team2Player1_2,
		&i.Team2Player2_2,
		&i.CreatedBy_2,
	)
	return i, err
}

const getMatchesForUserId = `-- name: GetMatchesForUserId :many
SELECT
  m.id, m.match_date, m.duration_minutes, m.created_by, m.team1_score, m.team1_player1, m.team1_player2, m.team2_score, m.team2_player1, m.team2_player2, m.created_at, m.updated_at,
  json_build_object(
    'id',
    u1.id,
    'name',
    u1.name,
    'email',
    u1.email,
    'image_url',
    u1.image_url
  ) AS team1_player1,
  json_build_object(
    'id',
    u2.id,
    'name',
    u2.name,
    'email',
    u2.email,
    'image_url',
    u2.image_url
  ) AS team1_player2,
  json_build_object(
    'id',
    u3.id,
    'name',
    u3.name,
    'email',
    u3.email,
    'image_url',
    u3.image_url
  ) AS team2_player1,
  json_build_object(
    'id',
    u4.id,
    'name',
    u4.name,
    'email',
    u4.email,
    'image_url',
    u4.image_url
  ) AS team2_player2,
  json_build_object(
    'id',
    u5.id,
    'name',
    u5.name,
    'email',
    u5.email,
    'image_url',
    u5.image_url
  ) AS created_by
FROM
  matches m
  LEFT JOIN users u1 ON m.team1_player1 = u1.id
  LEFT JOIN users u2 ON m.team1_player2 = u2.id
  LEFT JOIN users u3 ON m.team2_player1 = u3.id
  LEFT JOIN users u4 ON m.team2_player2 = u4.id
  LEFT JOIN users u5 ON m.created_by = u5.id
WHERE
  m.created_by = $1
  OR m.team1_player1 = $1
  OR m.team1_player2 = $1
  OR m.team2_player1 = $1
  OR m.team2_player2 = $1
ORDER BY
  m.match_date DESC
`

type GetMatchesForUserIdRow struct {
	ID              uuid.UUID
	MatchDate       time.Time
	DurationMinutes int32
	CreatedBy       uuid.UUID
	Team1Score      int32
	Team1Player1    uuid.UUID
	Team1Player2    uuid.NullUUID
	Team2Score      int32
	Team2Player1    uuid.NullUUID
	Team2Player2    uuid.NullUUID
	CreatedAt       time.Time
	UpdatedAt       sql.NullTime
	Team1Player1_2  json.RawMessage
	Team1Player2_2  json.RawMessage
	Team2Player1_2  json.RawMessage
	Team2Player2_2  json.RawMessage
	CreatedBy_2     json.RawMessage
}

func (q *Queries) GetMatchesForUserId(ctx context.Context, createdBy uuid.UUID) ([]GetMatchesForUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchesForUserId, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchesForUserIdRow
	for rows.Next() {
		var i GetMatchesForUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.MatchDate,
			&i.DurationMinutes,
			&i.CreatedBy,
			&i.Team1Score,
			&i.Team1Player1,
			&i.Team1Player2,
			&i.Team2Score,
			&i.Team2Player1,
			&i.Team2Player2,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Team1Player1_2,
			&i.Team1Player2_2,
			&i.Team2Player1_2,
			&i.Team2Player2_2,
			&i.CreatedBy_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentMatchesForUserId = `-- name: GetRecentMatchesForUserId :many
SELECT
  m.id, m.match_date, m.duration_minutes, m.created_by, m.team1_score, m.team1_player1, m.team1_player2, m.team2_score, m.team2_player1, m.team2_player2, m.created_at, m.updated_at,
  json_build_object(
    'id',
    u1.id,
    'name',
    u1.name,
    'email',
    u1.email,
    'image_url',
    u1.image_url
  ) AS team1_player1,
  json_build_object(
    'id',
    u2.id,
    'name',
    u2.name,
    'email',
    u2.email,
    'image_url',
    u2.image_url
  ) AS team1_player2,
  json_build_object(
    'id',
    u3.id,
    'name',
    u3.name,
    'email',
    u3.email,
    'image_url',
    u3.image_url
  ) AS team2_player1,
  json_build_object(
    'id',
    u4.id,
    'name',
    u4.name,
    'email',
    u4.email,
    'image_url',
    u4.image_url
  ) AS team2_player2,
  json_build_object(
    'id',
    u5.id,
    'name',
    u5.name,
    'email',
    u5.email,
    'image_url',
    u5.image_url
  ) AS created_by
FROM
  matches m
  LEFT JOIN users u1 ON m.team1_player1 = u1.id
  LEFT JOIN users u2 ON m.team1_player2 = u2.id
  LEFT JOIN users u3 ON m.team2_player1 = u3.id
  LEFT JOIN users u4 ON m.team2_player2 = u4.id
  LEFT JOIN users u5 ON m.created_by = u5.id
WHERE
  match_date > NOW() - INTERVAL '1 month'
  AND (
    m.created_by = $1::uuid
    OR m.team1_player1 = $1::uuid
    OR m.team1_player2 = $1::uuid
    OR m.team2_player1 = $1::uuid
    OR m.team2_player2 = $1::uuid
  )
ORDER BY
  match_date DESC
LIMIT
  10
`

type GetRecentMatchesForUserIdRow struct {
	ID              uuid.UUID
	MatchDate       time.Time
	DurationMinutes int32
	CreatedBy       uuid.UUID
	Team1Score      int32
	Team1Player1    uuid.UUID
	Team1Player2    uuid.NullUUID
	Team2Score      int32
	Team2Player1    uuid.NullUUID
	Team2Player2    uuid.NullUUID
	CreatedAt       time.Time
	UpdatedAt       sql.NullTime
	Team1Player1_2  json.RawMessage
	Team1Player2_2  json.RawMessage
	Team2Player1_2  json.RawMessage
	Team2Player2_2  json.RawMessage
	CreatedBy_2     json.RawMessage
}

func (q *Queries) GetRecentMatchesForUserId(ctx context.Context, userID uuid.UUID) ([]GetRecentMatchesForUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentMatchesForUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentMatchesForUserIdRow
	for rows.Next() {
		var i GetRecentMatchesForUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.MatchDate,
			&i.DurationMinutes,
			&i.CreatedBy,
			&i.Team1Score,
			&i.Team1Player1,
			&i.Team1Player2,
			&i.Team2Score,
			&i.Team2Player1,
			&i.Team2Player2,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Team1Player1_2,
			&i.Team1Player2_2,
			&i.Team2Player1_2,
			&i.Team2Player2_2,
			&i.CreatedBy_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatch = `-- name: UpdateMatch :exec
UPDATE matches
SET
  match_date = $2,
  duration_minutes = $3,
  team1_score = $4,
  team1_player1 = $5,
  team1_player2 = $6,
  team2_score = $7,
  team2_player1 = $8,
  team2_player2 = $9,
  updated_at = NOW()
WHERE
  id = $1
  AND created_by = $10::uuid
`

type UpdateMatchParams struct {
	ID              uuid.UUID
	MatchDate       time.Time
	DurationMinutes int32
	Team1Score      int32
	Team1Player1    uuid.UUID
	Team1Player2    uuid.NullUUID
	Team2Score      int32
	Team2Player1    uuid.NullUUID
	Team2Player2    uuid.NullUUID
	CreatedBy       uuid.UUID
}

func (q *Queries) UpdateMatch(ctx context.Context, arg UpdateMatchParams) error {
	_, err := q.db.ExecContext(ctx, updateMatch,
		arg.ID,
		arg.MatchDate,
		arg.DurationMinutes,
		arg.Team1Score,
		arg.Team1Player1,
		arg.Team1Player2,
		arg.Team2Score,
		arg.Team2Player1,
		arg.Team2Player2,
		arg.CreatedBy,
	)
	return err
}
